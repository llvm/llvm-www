<!--#include virtual="header.incl" -->

<div class="www_sectiontitle">Open LLVM Projects</div>

<ul>
  <li><a href="#gsoc18">Google Summer of Code 2018</a>
    <ul>
    <li>
      <b>LLVM Core</b>
      <ul>
  	    <li><a href="#codegen_testing2018">Improve code generation testing</a></li>
      </ul>
      <ul>
  	    <li><a href="#llvm_optimized_debugging">Improve debugging of optimized code</a></li>
      </ul>
      <ul>
	<li><a href="#replace_binary_utilities">Command line replacements for GNU Binutils</a></li>
      </ul>
      <ul>
        <li><a href="#llvm_domtree_updater">Implement a single updater class for Dominators</a></li>
      </ul>
      <ul>
        <li><a href="#llvm_function_attributes">Improve function attribute inference</a></li>
      </ul>
    </li>
    <li>
    <a href="http://clang.llvm.org/"><b>Clang</b></a><ul>
      <li><a href="#clang-template-instantiation-sugar">Extend clang AST to
          provide information for the type as written in template
          instantiations</a>
      </li>
      <li>
        <a href="#improve-autocompletion">Improve shell autocompletion for Clang</a>
      </li>
    </ul>
    </a>
    <a href="http://lldb.llvm.org/"><b>LLDB</b></a><ul>
      <li><a href="#lldb-data-formatters">Implement a DSL for LLDB data formatters</a>
      </li>

      <li><a href="#lldb-reimplement-lldb-mi">Reimplement lldb-mi on top of the
          LLDB public API</a>
      </li>

      <li><a href="#lldb-reimplement-lldb-cmdline">Reimplement LLDB's
          command-line commands using the public SB API.</a>
      </li>
      <li><a href="#lldb-batch-testing">Add support for batch-testing to the LLDB
          testsuite.</a>
      </li>
    </ul>
    </li>
    <li>
        <b>Packaging</b>
        <ul>
            <li><a href="#apt">Integrate libc++ and OpenMP in apt.llvm.org</a>
            </li>
            <li><a href="#apt-obs">Move the apt.llvm.org CI to OBS</a>
            </li>
        </ul>
   </li>
   <li>
        <b>Clang Static Analyzer</b>
        <ul>
            <li><a href="#analyzer-std-string-checker">Create a checker for dangling string pointers in C++</a>
            </li>
            <li><a href="#analyzer-z3-smt">Integrate with Z3 SMT solver to reduce false positives</a>
            </li>
        </ul>
   </li>
    <li>
      <b>Clang Tools Extra</b>
      <ul>
          <li><a href="#doc-html-generator">Implement an HTML generator for clang-doc</a>
          </li>
      </ul>
   </li>
   </ul>
  </li>
  <li><a href="#gsoc17">Google Summer of Code 2017</a>
    <ul>
    <li>
    <b>LLVM Core</b><ul>
	  <li><a href="#bitcode_fuzzing">Fuzzing the Bitcode reader</a></li>
	  <li><a href="#debuginfo_overhead">Improve optimizer overhead with debug info</a></li>
	  <li><a href="#thinlto_global">ThinLTO: propagating more global informations</a></li>
	  <li><a href="#debuginfo_codegen_mismatch">Adding Debug Info shouldn't change the generated code</a></li>
	  <li><a href="#hashmap_codegen_mismatch">Changing hashmap iteration order should not change the generated code</a></li>
	  <li><a href="#opt_remarks">We need better optimization remarks!</a></li>
	  <li><a href="#llvmir_dump">Smarter way of dumping LLVM IR with -emit-after-all</a></li>
	  <li><a href="#codegen_testing">Improve code generation testing</a></li>
    </ul>
    </li><li>
    <a href="http://clang.llvm.org/"><b>Clang</b></a><ul>
      <li><a href="#clang-template-instantiation-sugar">Extend clang AST to
          provide information for the type as written in template
          instantiations</a>
      </li>
      <li><a href="#clang-shell-autocompletion-support">Shell auto-completion
          support for clang</a>
      </li>
      <li><a href="#clang-diff-tool">Clang-based C/C++ diff tool</a></li>
    </ul>
    </li><li>
    <a href="http://clang.llvm.org/extra/clang-tidy/"><b>Clang-tidy</b></a><ul>
      <li><a href="#clang-tidy-pointer-deref">Find dereference of pointers</a>
      </li>
    </ul>
    </li><li>
    <a href="http://clang-analyzer.llvm.org/"><b>Clang Static Analyzer</b></a><ul>
      <li><a href="#clang-sa-virt-calls">Warn if virtual calls are made from
          constructors or destructors</a>
      </li>
      <li><a href="#clang-sa-atomics">Model C++11 and C11 atomics in the
          analyzer</a>
      </li>
    </ul>
    </li><li>
    <a href="http://compiler-rt.llvm.org/"><b>Compiler-rt</b></a><ul>
      <li><a href="#compiler-rt-port-to-other-platforms">Port compiler-rt
          components to other platforms</a>
      </li>
    </ul>
    </li><li>
    <a href="http://lld.llvm.org/"><b>LLD</b></a><ul>
      <li><a href="#lld_layout">Improve Code Layout</a>
      </li>
    </ul>
    </li><li>
    <b><a href="http://polly.llvm.org">Polly</a></b><ul>
      <li>
  <a href="#pollypgo">Profile Guided Optimization in Polly</a></li>
  <li><a href="#pollypassmanager">Move Polly to the new LLVM pass manager</a>
      </li>
    </ul>
    </li>
    </ul>

  </li>
  <li><a href="#what">What is this?</a></li>
  <li><a href="#subprojects">LLVM Subprojects: Clang and more</a></li>
  <li><a href="#improving">Improving the current system</a>
  <ol>
    <li><a href="#target-desc">Factor out target descriptions</a></li>
    <li><a href="#code-cleanups">Implementing Code Cleanup bugs</a></li>
    <li><a href="#programs">Compile programs with the LLVM Compiler</a></li>
    <li><a href="#llvmtest">Add programs to the llvm-test suite</a></li>
    <li><a href="#benchmark">Benchmark the LLVM compiler</a></li>
    <li><a href="#statistics">Benchmark Statistics and Warning System</a></li>
    <li><a href="#coverage">Improving Coverage Reports</a></li>
    <li><a href="#misc_imp">Miscellaneous Improvements</a></li>
  </ol></li>

  <li><a href="#new">Adding new capabilities to LLVM</a>
  <ol>
    <li><a href="#llvm_ir">Extend the LLVM intermediate representation</a></li>
    <li><a href="#pointeranalysis">Pointer and Alias Analysis</a></li>
    <li><a href="#profileguided">Profile-Guided Optimization</a></li>
    <li><a href="#compaction">Code Compaction</a></li>
    <li><a href="#xforms">New Transformations and Analyses</a></li>
    <li><a href="#codegen">Code Generator Improvements</a></li>
    <li><a href="#misc_new">Miscellaneous Additions</a></li>
  </ol></li>

  <li><a href="#using">Project using LLVM</a>
  <ol>
    <li><a href="#machinemodulepass">Add a MachineModulePass</a></li>
    <li><a href="#encodeanalysis">Encode Analysis Results in MachineInstr IR</a></li>
    <li><a href="#codelayoutjit">Code Layout in the LLVM JIT</a></li>
    <li><a href="#fieldlayout">Improved Structure Splitting and Field Reordering</a></li>
    <li><a href="#slimmer">Finish the Slimmer Project</a></li>
  </ol></li>
</ul>

<div class="doc_author">
  <p>Written by the <a href="http://llvm.org/">LLVM Team</a></p>
</div>

<!-- *********************************************************************** -->
<div class="www_sectiontitle">
  <a name="gsoc18">Google Summer of Code 2018</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">

<p>
Welcome prospective Google Summer of Code 2018 Students! This document is your
starting point to finding interesting and important projects for LLVM, Clang,
and other related sub-projects. This list of projects is not just developed for
Google Summer of Code, but open projects that really need developers to work on
and are very beneficial for the LLVM community. </p>

<p>We encourage you to look through this list and see which projects excite you
and match well with your skill set. We also invite proposals not on this
list. However, you must propose your idea to the LLVM community through our
developers' mailing list (llvm-dev@lists.llvm.org or specific subproject mailing
list). Feedback from the community is a requirement for your proposal to be
considered and hopefully accepted.
</p>

<p>The LLVM project has participated in Google Summer of Code for several years
and has had some very successful projects. We hope that this year is no
different and look forward to hearing your proposals. For information on how to
submit a proposal, please visit the Google Summer of Code
main <a href="https://developers.google.com/open-source/gsoc/">website.</a></p>


<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>LLVM</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="codegen_testing2018">Improve code generation testing</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p>
    <b>Description of the project:</b>
    After instruction selection LLVM uses the MI (Machine Instruction)
    representation for programs. We recently added support for reading and
    writing this representation to disk
    (<a href="http://llvm.org/docs/MIRLangRef.html">http://llvm.org/docs/MIRLangRef.html</a>). Usage of this format for writing
    tests is growing and so is the desire to improve the format, tools and
    workflow. Possible projects:
  </p>

  <ul>
    <li>Create a single consistent format instead of the current mix of YAML + IR + MIR</li>
    <li>Helper passes: Strip IR information, rename blocks and values, debug information, extract functions or blocks...</li>
    <li>Create a bugpoint mode (or a new tool) to reduce .mir test cases</li>
    <li>Create tool to remove unnecessary information from existing tests</li>
  </ul>

  <p><b>Confirmed Mentor:</b> Matthias Braun</p>
  <p><b>Desirable skills:</b> Intermediate knowledge of C++.</p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="llvm_optimized_debugging">Improve debugging of optimized code</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p>
  <b>Description of the project:</b> Debugging optimized code can be frustrating. Variables may appear as "&lt;value optimized out&gt;" in the debugger, or may not appear at all. Line numbers in stack traces may disappear, or worse, become inaccurate. To improve the situation, we have to teach more LLVM optimization passes how to preserve debug info. The primary focus will be on mid-level IR passes which fail to pass verification by the <a href="https://reviews.llvm.org/D40512">Debugify utility</a>. This utility can identify passes which drop debug info in a targeted way and can simplify test case generation.
  </p>
  <p><b>Expected Results:</b>This project has two goals. Initially, the student will gather metrics on debug info loss for individual llvm passes. This will let us measure subsequent improvements. The second goal is to incrementally fix as many debug info loss bugs as possible, with a focus on areas of the compiler which are the hottest.</p>

  <p><b>Confirmed Mentor:</b> Vedant Kumar and Davide Italiano</p>
  <p><b>Desirable skills:</b> Intermediate knowledge of C++.</p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="replace_binary_utilities">Command line replacements for GNU Binutils</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b> The llvm project has a lot of tools that can be used to inspect binaries, just as any other toolchain project does. However, many people are accustomed to existing tools and so having a command line compatible shell and we'd like to make that easy for them. Bonus points for producing similar output so that automated tools can continue to work reliably.
  <p><b>Expected Results:</b>This project has one goal - produce binary tools that are drop in compatible with GNU binutils. The student will be expected to focus on a single tool at a time so that we can count each one as "done" as much as possible.

  <p><b>Confirmed Mentor:</b> Eric Christopher and Sterling Augustine</p>
  <p><b>Desirable skills:</b> Intermediate knowledge of C++.</p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="llvm_domtree_updater">Implement a single updater class for Dominators</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b> Dominance relation is used widely in many compiler analyses and optimizations. LLVM provides an implementation of the (Semi-NCA) Depth Based Search algorithm to incrementally update Dominator and PostDominator Trees. It it possible to use it directly or through a lazy updater object -- DeferredDominance. The current API is fragmented and different analyzes, transforms, and utilities (e.g. Local.cpp, LoopUnroll.cpp) have to decide how to perform incremental updates.
  </p>
  <p>The fix would be to design and implement a new class for abstracting away how tree updates are performed (eagerly or lazily) and which trees are actually being updated (none, only DomTree, only PostDomTree, both). With this, performing faster incremental updates will become possible by first updating DomTree, and then using the result to prune unnecessary updates to PostDomTree.</p>

  <p>Expected Results:
    <ul><li>Create a new class that will store Dominator Trees to update and allow to specify update policy.</li></ul>
    <ul><li>Convert existing API to use the new updater object instead of working directly with DomTree/DeferredDominance.</li></ul>
    <ul><li>Design and implement a new algorithm to prune unnecessary PostDomTree updates based on updated DomTree.</li></ul>
    <ul><li>(Optional) Explore more strategies for performing lazy updates (e.g. by exposing .dominates() and performing updates when called).</li></ul>
  </p>
  <p><b>Confirmed Mentor:</b> Jakub Kuderski, Tobias Grosser (?)</p>
  <p><b>Desirable skills:</b> Intermediate knowledge of C++. Familiarity with basic tree/graph algorithms and data structures.</p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="llvm_function_attributes">Improve function attribute inference</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b> LLVM functions can be tagged with several <a href="http://llvm.org/docs/LangRef.html#function-attributes">attributes</a> such as the function only reads memory, or the function cannot throw exceptions. These attributes are used by many optimizations when deciding if a particular transformation is valid or not. Functions attributes can be either given by the frontend or be inferred by LLVM.<br>
  The goal of this project is to improve current function attributes inference algorithms, and to infer attributes that are not inferred right now. This will be accomplished via intra- and/or inter-procedural analyses. See <a href="http://lists.llvm.org/pipermail/llvm-dev/2018-February/121269.html">this email</a> for a list of oportunities for improvement.</p>
  <p><b>Confirmed Mentor:</b> Nuno Lopes</p>
  <p><b>Desirable skills:</b> Intermediate knowledge of C++. Optional familiarity with static analysis/abstract interpretation.</p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>Clang</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="improve-autocompletion">Improve shell autocompletion for Clang</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b> Clang has a newly implemented autocompletion feature which details can be found at <a href="http://blog.llvm.org/2017/09/clang-bash-better-auto-completion-is.html">LLVM blog</a>. We would like to improve this by adding more flags to autocompletion, supporting more shells (currently it supports only bash) and exporting this feature to other projects such as llvm-opt. Accepted student will be working on Clang Driver, LLVM Options and shell scripts.
  </p>

  <p><b>Expected Results:</b> Autocompletion working on bash and zsh, support llvm-opt options.</p>

  <p><b>Confirmed Mentor:</b> Yuka Takahashi and Vassil Vassilev</p>

  <p><b>Desirable skills:</b>
  Intermediate knowledge of C++ and shell scripting
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>LLDB</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="lldb-reimplement-lldb-cmdline">Reimplement LLDB's command-line commands
  using the public SB API.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b> Just as LLVM is a library to
    build compilers, LLDB is a library to build debuggers. LLDB vends
    a stable, public SB API. Due to historic reasons the LLDB command
    line interface is currently implemented on top of LLDB's private
    API and it duplicates a lot of functionality that is already
    implemented in the public API. Rewriting LLDB's command line
    interface on top of the public API would simplify the
    implementation, eliminate duplicate code, and most importantly
    reduce the testing surface.
  </p>
  <p>
    This work will also provide an opportunity to clean up the SB API
    of commands that have accrued too many overloads over time and
    convert them to make use of option classes to both gather up all
    the variants and also future-proof the APIs.
  </p>
  <p><b>Confirmed Mentor:</b>Adrian Prantl and Jim Ingham</p>

  <p><b>Desirable skills:</b>
    Intermediate knowledge of C++.
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="lldb-data-formatters">Implement a DSL for LLDB data formatters</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b> LLDB's data formatters allow it to pretty-print objects such as std::vector (from the C++ standard library), or String (from the Swift standard library). These data formatters are implemented in C++ and reside within the debugger, but the data structures are defined in other projects. This means that when the data structures change, lldb's data formatters may not be updated in sync. This also means that it's difficult for projects to define and test custom data formatters for special kinds of objects.  </p>
  <p><b>Expected results: </b> The goal of this project would be to define a DSL which makes it possible to implement lldb data formatters for standard C++ containers. These formatters would be moved into libc++ and tested there. </p>
  <p><b>Confirmed Mentor:</b> Vedant Kumar and Davide Italiano</p>

  <p><b>Desirable skills:</b>
    Intermediate knowledge of C++.
  </p>
</div>


<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="lldb-reimplement-lldb-mi">Reimplement lldb-mi on top of the LLDB
    public SB API.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b> <em>lldb-mi</em> implements a
    machine-readable interface that is supported by many IDEs and text
    editors. The current support is incomplete and does not implement
    enough commands to work with most text editors. More importantly,
    it isn't using the right abstraction layer: Instead of executing
    textual commands via <em>handleCommand()</em> and scraping LLDB's
    textual output, it should be using the methods and data structures
    provided by the public SB API.
  </p>
  <p><b>Confirmed Mentor:</b> Adrian Prantl</p>

  <p><b>Desirable skills:</b>
    Intermediate knowledge of C++.
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="lldb-batch-testing">Add support for batch-testing to the LLDB
    testsuite.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>One of the tensions in the
    testsuite is that spinning up a process and getting it to some
    point is not a cheap operation, so you'd like to do a bunch of
    tests when you get there.  But the current testsuite bails at the
    first failure, so you don't want to do many tests since the
    failure of one fails all the others. On the other hand, there are
    some individual test assertions where the failure of the assertion
    <em>should</em> cause the whole test to fail.  For example, if you
    fail to stop at a breakpoint where you want to check some variable
    values, then the whole test should fail.  But if your test then
    wants to check the value of five independent locals, it should be
    able to do all five, and then report how many of the five variable
    assertions failed. We could do this by adding <em>Start</em>
    and <em>End</em> markers for a batch of tests, do all the tests in
    the batch without failing the whole test, and then report the
    error and fail the whole test if appropriate. There might also be
    a nice way to do this in Python using scoped objects for the test
    sections.
  </p>
  <p><b>Confirmed Mentor:</b> Jim Ingham</p>

  <p><b>Desirable skills:</b>
    Intermediate knowledge of Python.
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>Others</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="apt">Integrate libc++ and OpenMP in apt.llvm.org</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
  <a href="https://apt.llvm.org">apt.llvm.org</a> provides Debian and Ubuntu repositories for every maintained version of these distributions. LLVM, Clang, clang extra tools, compiler-rt, polly, LLDB and LLD packages are generated for the stable, stabilization and development branches.<br />
  These packages are also shipped as part of Debian and Ubuntu without any changes.<br />
  Debian and Ubuntu have separate packages for <a href="https://packages.qa.debian.org/libc/libc++.html">libc++</a> and <a href="https://packages.qa.debian.org/o/openmprtl.html">OpenMP</a>.<br />
  The goal of this project is to merge libc++ and OpenMP packages as part of the llvm-toolchain packages.<br />
  The difficulty of this project is to make different versions of these libraries co-installable while remaining usable for developers. This project will also aim to limit the impact on existing usage of these libraries.
  </p>

  <p>If the project is completed early, the student will also work on the full bootstrap of the llvm-toolchain (ie building it with a newly built clang binary).</p>

  <p><b>Expectation:</b> The student must have demonstrated some experience with Debian/Ubuntu packaging. Debian maintains a list of <a href="https://bugs.debian.org/cgi-bin/pkgreport.cgi?tag=newcomer">good first bugs</a>. Please mention any packaging related contribution in the GSoC application.</p>

  <p><b>Confirmed Mentor:</b> <a href="mailto:sylvestre@debian.org">Sylvestre Ledru</a></p>

  <ul>
    <li>More about libc++: <a href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=813673">https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=813673</a>
    <li>More about OpenMP: <a href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=813672">https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=813672</A>
  </ul>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="apt-obs">Move the apt.llvm.org CI to OBS</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
  <a href="https://apt.llvm.org">apt.llvm.org</a> provides Debian and Ubuntu repositories for every maintained version of these distributions. LLVM, Clang, clang extra tools, compiler-rt, polly, LLDB and LLD packages are generated for the stable, stabilization and development branches.<br />
  Currently, the packages are build using a <a href="http://llvm-jenkins.debian.net/">Jenkins instance</a> and <a href="https://github.com/mika/jenkins-debian-glue/">Jenkins-Debian-Glue</a>.<br />
  The goal of this project is to deploy an instance of <a href="http://openbuildservice.org/">Open Build Service (OBS)</a> and port the <a href="https://github.com/sylvestre/llvm-jenkins.debian.net">various scripts</a> and packages to this platform.
  </p>

  <p>In theory, apt.llvm.org should not have any change from the user perspective.</p>

  <p><b>Expectation:</b> The student must have demonstrated some experience with Debian/Ubuntu packaging. Debian maintains a list of <a href="https://bugs.debian.org/cgi-bin/pkgreport.cgi?tag=newcomer">good first bugs</a>. Please mention any packaging related contribution in the GSoC application.</p>

  <p><b>Confirmed Mentor:</b> <a href="mailto:sylvestre@debian.org">Sylvestre Ledru</a></p>

  <ul>
    <li>More about libc++: <a href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=813673">https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=813673</a>
    <li>More about OpenMP: <a href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=813672">https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=813672</A>
  </ul>
</div>

<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>Clang Static Analyzer</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="analyzer-std-string-checker">Create a checker for dangling string pointers in C++.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
    The C++ std::string class provides a c_str() method that returns a raw pointer to a string's inner character buffer. When a std::string is destroyed, the character buffer is deallocated. A common bug is to access a dangling raw pointer to the buffer after string deallocation. These "use after free" bugs can cause crashes or other unexpected behavior. 
    <br />
    This project will add a new checker to the static analyzer to find when a dangling inner string pointer is used. This will help find bugs not only with std::string and c_str() but also with LLVM's StringRef class and the new C++17 std::string_view.
  </p>
  <p><b>Confirmed Mentor:</b> Artem Dergachev</p>
  <p><b>Desirable skills:</b> Intermediate knowledge of C++.</p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="analyzer-z3-smt">Integrate with Z3 SMT solver to reduce false positives.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
    The static analyzer finds bugs by exploring many possible paths through a program. To reduce false positives, it uses a very fast but imprecise custom constraint manager to rule out infeasible paths that cannot actually be executed at run time.
    <br />    
    This project will extend the analyzer to use the <a href="https://github.com/Z3Prover/z3/wiki">Z3 SMT solver</a> to rule out additional infeasible paths by postprocessing bug reports. This will help the analyzer reduce false positives when the path involves complicated branches that the built-in constraint manager cannot reason about.
  </p>
  <p><b>Confirmed Mentor:</b> George Karpenkov</p>
  <p><b>Desirable skills:</b> Intermediate knowledge of C++ and basic familiarity with the capabilities SMT solvers</p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>Clang Tools Extra</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="doc-html-generator">Create a checker for dangling string pointers in C++.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
   Clang-doc is a new tool for generating documentation for C/C++ code with a modular and extensible approach. It aims to simplify the overhead of generating documentation, leveraging the clang AST to produce results from existing comments and code. The main part of the tool produces an intermediate representation of the docs, which is consumed by a generator targeting a specific output format. Current and in-progress generators emit documentation in YAML and Markdown formats, but we’d like to have another one for HTML format.
  </p>
  <p><b>Confirmed Mentor:</b> Julie Hockett</p>
  <p><b>Desirable skills:</b> Intermediate knowledge of C++.</p>
</div>

<!-- *********************************************************************** -->
<div class="www_sectiontitle">
  <a name="gsoc17">Google Summer of Code 2017</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">

<p>Google Summer of Code 2017 contributed a lot to the LLVM project. Below is a
list of some projects that were offerred during GSoC 2017. For the list of
accepted and completed projects, please take a look into Google Summer of Code
<a href="https://summerofcode.withgoogle.com/archive/2017/organizations/6215410651234304/">website.
</a></p>


<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>LLVM</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="bitcode_fuzzing">Fuzzing the Bitcode reader</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="debuginfo_overhead">Improve optimizer overhead with debug info</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
	  The optimizer is 25-30% slower when debug info are enabled, it'd be nice
	  to track all the places where we don't do a good job about ignoring them!
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="thinlto_global">ThinLTO: propagating more global informations across
	  the program for more powerful optimizations!</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
	  ThinLTO is a cool new technology to perform Link-Time Optimization (see
	  <a href="http://llvm.org/devmtg/2016-11/#talk12">this talk</a> for more info). It is fairly new
	  and there are multiple improvements about cross-module optimizations that
	  can be made there.
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="debuginfo_codegen_mismatch"></a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
	  Adding Debug Info (compiling with `clang -g`) shouldn't change the
	  generated code at all. Unfortunately we have bugs… These are usually not
	  too hard to fix and a good way to discover new part of the codebase! A
	  starting point could be the test-suite. We suggest building object files
	  both ways and disassembling the text sections, which will give cleaner
	  diffs than comparing .s files.
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="hashmap_codegen_mismatch">Changing the iteration order of unordered
	  datastructures should not change the generated code.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="opt_remarks">We need better optimization remarks!</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
	  See <a href="http://llvm.org/devmtg/2016-11/#talk15">this talk</a>
	  for a starting point.  Please take a look at the list of
	  enhancements and bugs in <a href=
	  "https://bugs.llvm.org/buglist.cgi?component=opt-viewer&list_id=125824&product=tools&query_format=advanced&resolution=---">
	  bugzilla</a>.
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="llvmir_dump">Smarter way of dumping LLVM IR with -emit-after-all</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
	  Smarter way of dumping LLVM ir with -emit-after-all - dump only if it
	  differs from last pass. Maybe small color the IR?
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="codegen_testing">Improve code generation testing</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project:</b>
	  After instruction selection LLVM uses the MI (Machine Instruction)
	  representation for programs. We recently added support for reading and
	  writing this representation to disk
	  (<a href="http://llvm.org/docs/MIRLangRef.html">http://llvm.org/docs/MIRLangRef.html</a>). Usage of this format for writing
	  tests is growing and so is the desire to improve the format, tools and
	  workflow. Improvements would be welcome:

	  <ul><li>Create a single consistent format instead of the current mix of
		  YAML + IR + MIR</li></ul>
	  <ul><li>Do not print unnecessary information (we often print default
		  values where the reader could deduce them)</li></ul>
	  <ul><li>The format of things like MachineInstr/MachineBasicBlock::dump()
		  should be the same or very close to the .mir format => change the dump
		  functions.</li></ul>
	  <ul><li>Allow the representation to deduce successors of a basic block in
		  common cases</li></ul>
	  <ul><li>Allow symbolic names instead of just numbers for virtual
		  registers</li></ul>
	  <ul><li>Helper passes: Strip IR information, rename blocks and values,
		  debug information, ...</li></ul>
	  <ul><li>Create a bugpoint mode (or a new tool) to reduce .mir test cases</li></ul>
	  <ul><li>Write recommendations and guides for .mir based tests</li></ul>
  </p>

   <p><b>Confirmed Mentor:</b> Matthias Braun</p>
</div>


<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>Clang</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="clang-template-instantiation-sugar">Extend clang AST to provide
    information for the type as written in template instantiations.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
    When instantiating a template, the template arguments are canonicalized
    before being substituted into the template pattern. Clang does not preserve
    type sugar when subsequently accessing members of the instantiation.

    <pre>
    std::vector&lt;std::string&gt; vs;
    int n = vs.front(); // bad diagnostic: [...] aka 'std::basic_string&lt;char&gt;' [...]

    template&lt;typename T&gt; struct Id { typedef T type; };
    Id&lt;size_t&gt;::type // just 'unsigned long', 'size_t' sugar has been lost
    </pre>

    Clang should "re-sugar" the type when performing member access on a class
    template specialization, based on the type sugar of the accessed
    specialization. The type of vs.front() should be std::string, not
    std::basic_string&lt;char, [...]&gt;.
    <br /> <br />
    Suggested design approach: add a new type node to represent template
    argument sugar, and implicitly create an instance of this node whenever a
    member of a class template specialization is accessed. When performing a
    single-step desugar of this node, lazily create the desugared representation
    by propagating the sugared template arguments onto inner type nodes (and in
    particular, replacing Subst*Parm nodes with the corresponding sugar). When
    printing the type for diagnostic purposes, use the annotated type sugar to
    print the type as originally written.
    <br /> <br />
    For good results, template argument deduction will also need to be able to
    deduce type sugar (and reconcile cases where the same type is deduced twice
    with different sugar).
  </p>

  <p><b>Expected results: </b>
    Diagnostics preserve type sugar even when accessing members of a template
    specialization. T&lt;unsigned long&gt; and T&lt;size_t&gt; are still the
    same type and the same template instantiation, but
    T&lt;unsigned long&gt;::type single-step desugars to 'unsigned long' and
    T&lt;size_t&gt;::type single-step desugars to 'size_t'.

  <p><b>Confirmed Mentor:</b> Vassil Vassilev, Richard Smith</p>

  <p><b>Desirable skills:</b>
    Good knowledge of clang API, clang's AST, intermediate knowledge of C++.
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="clang-shell-autocompletion-support">Shell auto-completion support for
    clang.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
    Bash and other shells support typing a partial command and then
    automatically completing it for the user (or at least providing suggestions
    how to complete) when pressing the tab key. This is usually only supported
    for popular programs such as package managers (e.g. pressing tab after
    typing "apt-get install late" queries the APT package database and lists all
    packages that start with "late"). As of now clang's frontend isn't supported
    by any common shell.

    <br /> <br />
    Suggested design approach: The main goal is to support a variety of
    terminals. It would be preferable to keep each shell plugin minimal,
    enabling easy addition of new plugins. The implementation ought to extend
    the clang driver switches with a flag to request auto-completion of a
    partial shell command.
    <br /> <br />

    The final auto-completion support should contain features such as:
    <ul>
      <li>Searching/correcting all flags. For example:
        <ul>
          <li>typing <code>clang -tri<i>[tab]</i></code> should complete to
            <code>-trigraphs</code>
          </li>
          <li>typing <code>clang -cc1 -dump-decls<i>[tab]</i></code> should
            correct <code>-dump-decls</code> to <code>-dump-deserialized-decls</code>
          </li>
        </ul>
      </li>
      <li>Searching for valid arguments for the flags. For example:
        <ul>
          <li>typing <code>clang -cc1 -analyze -analyzer-checker=<i>[tab]</i> -fsyntax-only</code>
            should list all available static analyzers (eg. core.DivideZero)
          </li>
          <li>typing <code>clang -std=<i>[tab]</i></code> should list the
            available language standards.
          </li>
        </ul>
      </li>
      <li>When the auto-completion for a partial command is ambiguous, all
        possible completions should be displayed with the relevant description
        from the "--help" output beside it (<a href="https://www.pablumfication.co.uk/wp-content/uploads/2010/02/fish-lsAutocompleteArguments.jpg">
          example of this in fish with the command "ls"</a>).
      </li>
    </ul>
  </p>

  <p><b>Expected results: </b>
    Bash supports abovementioned auto-complete examples on at least OS X and
    Linux.
  <p><b>Confirmed Mentor:</b> Vassil Vassilev, Raphael Isemann</p>

  <p><b>Desirable skills:</b>
    Intermediate knowledge of C++ and shell scripting, Intermediate knowledge of
    the clang driver.
  </p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="clang-diff-tool">Clang-based C/C++ diff tool.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
    Every developer has to interact with diff tools daily. The algorithms are
    usually based on detecting "longest common subsequences", which is agnostic
    to the file type content. A tool that would understand the structure of the
    code may provide a better diff experience by being robust against, for
    example, clang-format changes.
  </p>
  <p><b>Confirmed Mentor:</b> Mehdi Amini</p>
</div>


<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>Clang-tidy</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="clang-tidy-pointer-deref">Find dereference of pointers.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
    Find dereference of pointer before checking for nullptr, like:
    <pre>
      Int * p = foo();
      *p = 42;
      If (p != nullptr) { // p != nullptr is considered as always true
      }
      If (!p) { // !p is considered as always false
      }
    </pre>

    <br /><br />
    This check should be easier to write in clang-tidy than in Clang Static
    Analyzer, specially because that we don't care about inlining (as long as it
    doesn't modify pointer). More details in the
    <a href="https://llvm.org/bugs/show_bug.cgi?id=30232">Bugzilla feature
      request</a>
  </p>
  <p><b>Confirmed Mentor:</b> Alexander Kornienko, Piotr Padlewski</p>
</div>


<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>Clang Static Analyzer</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="clang-sa-virt-calls">Warn if virtual calls are made from constructors
    or destructors.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
    Implement a path-sensitive checker that warns if virtual calls are made from
    constructors and destructors, which is not valid in case of pure virtual
    calls and could be a sign of user error in <a href="https://isocpp.org/wiki/faq/strange-inheritance#calling-virtuals-from-ctors">non-pure calls</a>.
    <br />
    The current virtual calls checker, implemented in VirtualCallChecker.cpp,
    needs to be re-implemented in a path-sensitive way.  The lack of
    path-sensitive reasoning may result in false positives in the
    inter-procedural mode, which is disabled now for that reason.
    The false positives could happen when a called function uses a member
    variable flag to track whether initialization is complete and relies on the
    flag to ensure that the virtual member function is not called during
    initialization. Further, the path diagnostic should be used to highlight
    both the virtual call and the path from the constructor. Last, we will need
    to evaluate if the warning should be issued for both calls to pure virtual
    functions (which is always an error) and non-pure virtual functions (which
    is more of a code smell and may be a false positive).
  </p>
  <p><b>Confirmed Mentor:</b> Anna Zaks</p>
</div>

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="clang-sa-atomics">Model C++11 and C11 atomics in the analyzer.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
    Enhance the clang static analyzer by adding models of C++11 and C11 atomic
    operations, such as std::atomic_compare_exchange_*. Currently, these
    operations are being treated opaquely, which results in loss of precision
    when analyzing the code that uses these instructions. To address the
    problem, one would need to programmatically construct AST that simulates
    these APIs to the BodyFarm of the analyzer. BodyFarm is the API used for
    modeling system APIs. Finally, the work would also include writing tests
    for the various APIs and checking that the analyzer correctly models
    atomics.
  </p>
  <p><b>Confirmed Mentor:</b> Anna Zaks</p>
</div>



<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>Compiler-rt</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="compiler-rt-port-to-other-platforms">Port compiler-rt components to
    other platforms.</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
    Many of the projects in compiler-rt are only supported on Linux.
    <br />
    Here are some examples: CFI, DFSan, XSan, LSan, XRay. Porting any of them
    to other platforms, for example, Mac OS, would be great!
  </p>
  <p><b>Confirmed Mentor:</b> Kuba Mracek, Anna Zaks</p>
</div>


<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>LLD</a>
</div>
<!-- *********************************************************************** -->

<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="lld_layout">Improve Code Layout</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
	The goal for the project is trying to improve the layout/performances of the
	generated executable. The primary object format considered for the project
	is ELF but this can be extended to other object formats. The project will
	touch both LLVM and lld.
	<ul>
		<li>Warm-up: lld already provides an option to (--symbol-ordering file)
			which takes a symbol ordering file (presumably collected from a
			profiler) and builds a layout. This aims to reduce startup times. It
			would be nice to provide scripts to profile the applications/process
			various profilers output to produce an order file/evaluate the
			impact of the feature (as it has been tested only on a small class
			of applications). There's already some work in the area but nothing
			has been integrated in the LLVM build system for ELF. Ideally a
			motivated student would do the benchmarking/analysis before the GSoC
			starts to familiarize with the problem.</li>
		<li>The meat: Use/extend profile informations generated by LLVM to help
			the linker laying out functions. An obvious way (what gcc uses, [1])
			is to pass values to the linker using special `.note` sections. The
			linker then can reconstruct the call graph and apply an algorithm
			like the one described in [2] (this is just a starting point, other
			alternatives can be explored).</li>
	</ul>
  </p>
  <p>
	Possible extension: Xray can be used to provide data (it's unclear whether
	this is feasible easily, see David's comment in [3]).
  </p>
  <p><b>Confirmed Mentor:</b> Davide Italiano</p>

  <ul>
    <li>[1] <a href="http://sourceware.org/ml/binutils/2011-03/msg00043.html">http://sourceware.org/ml/binutils/2011-03/msg00043.html</a></li>
    <li>[2] <a href="http://dl.acm.org/citation.cfm?id=93550">http://dl.acm.org/citation.cfm?id=93550</a></li>
    <li>[3] <a href="http://lists.llvm.org/pipermail/llvm-dev/2017-January/109114.html">http://lists.llvm.org/pipermail/llvm-dev/2017-January/109114.html</a></li>
  </ul>
</div>

<!-- *********************************************************************** -->
<div class="www_subsection">
  <a>Polly</a>
</div>
<!-- *********************************************************************** -->


<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="pollypgo">Profile Guided Optimization in Polly</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
  Even though Polly's compile time is today not a lot higher than other non-trial
  IR passes, the need to version code in many situations and the lack of static
  knowledge about loop iteration counts, hotness of functions, and parameter
  requires Polly to be significantly more conservative than it would need to
  be. The goal of this project is to connect Polly with the LLVM profiling
  infrastructure to exploit profiling information to decide: 1) when to
  run Polly, 2) how aggressive to version the code, 3) which code version
  to emit, and 4) which assumptions to take. As a result, Polly should can
  in profile guided builds become more aggressive, while still having a lower
  compile time and code size impact.
  </p>

  <p><b>Confirmed Mentor:</b> <a href="mailto:tobias@grosser.es">Tobias Grosser</a></p>

  <ul>
    <li>PGO in LLVM: <a href="http://llvm.org/devmtg/2013-11/">2013 developer's meeting presentation</a>
  </ul>
</div>


<!-- *********************************************************************** -->
<div class="www_subsubsection">
  <a name="pollypassmanager">Move Polly to the new LLVM pass manager</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">
  <p><b>Description of the project: </b>
<p>Over the last years Chandler Carruth and others introduced a new pass manager
to LLVM which uses a new caching based architecture to allow analysis results
to be computed on demand. Besides resolving many engineering problems, the new
pass manager has three interesting properties: 1) analysis results for multiple
objects (e.g., functions) can be made available at the same time, 2) it is
possible to access the analysis result from one function in another function or
the analysis results from a function pass in a call-graph pass. 3) new pass
managers can be instantiated easily.
  </p>
<p>
The goal of this project is to port Polly to the new pass manager and use this
opportunity to improve the overall pass design of Polly. The first step will
be to make Polly future proof by providing the same functionality Polly already
has with the old pass manager, in the context of the new pass manager. Next,
facilities of the new pass manger can be exploited to remove Polly's dependence
on the RegionPass infrastructure, and replace it with a Polly specific
scop-pass manager, that executes scop-model only passes without the need to
piggy-pack on some IR level analysis. Finally, the student thinks about how
analysis results can be made available across functions.
</p>

<p>If the project is completed early, the student might look into exploiting
the availability of analysis results from multiple functions to perform GPU
code generation across functions</p>

<p><b>Confirmed Mentor:</b> <a href="mailto:tobias@grosser.es">Tobias Grosser</a></p>

<ul>
  <li>More about the LLVM Pass manager: <a href="http://llvm.org/devmtg/2014-10/">Chandlers Presentation on 2014 Developer's Meeeting</a>
</ul>
</div>

<!-- *********************************************************************** -->
<div class="www_sectiontitle">
  <a name="what">What is this?</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">

<p>This document is meant to be a sort of "big TODO list" for LLVM.  Each
project in this document is something that would be useful for LLVM to have, and
would also be a great way to get familiar with the system.  Some of these
projects are small and self-contained, which may be implemented in a couple of
days, others are larger.  Several of these projects may lead to interesting
research projects in their own right.  In any case, we welcome all
contributions.</p>

<p>If you are thinking about tackling one of these projects, please send a mail
to the <a href="http://lists.llvm.org/mailman/listinfo/llvm-dev">LLVM
Developer's</a> mailing list, so that we know the project is being worked on.
Additionally this is a good way to get more information about a specific project
or to suggest other projects to add to this page.
</p>

<p>The projects in this page are open-ended. More specific projects are
filed as unassigned enhancements in the <a href="http://bugs.llvm.org/">
LLVM bug tracker</a>. See the <a href="http://bugs.llvm.org/buglist.cgi?keywords_type=allwords&amp;keywords=&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;bug_severity=enhancement&amp;emailassigned_to1=1&amp;emailtype1=substring&amp;email1=unassigned">list of currently outstanding issues</a> if you wish to help improve LLVM.</p>

</div>

<!-- *********************************************************************** -->
<div class="www_sectiontitle">
  <a name="subprojects">LLVM Subprojects: Clang and More</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">

<p>In addition to hacking on the main LLVM project, LLVM has several subprojects,
   including Clang and others.  If you are interested in working on these, please
   see their "Open projects" page:</p>

<ul>
<li>The <a href="http://clang.llvm.org/OpenProjects.html">Clang Open
    Projects</a> list.</li>
<li>The <a href="http://polly.llvm.org/projects.html">Polly Open
    Projects</a> list.</li>
<li>The <a href="http://sva.cs.illinois.edu/projects.html">SAFECode Open
    Projects</a> list.</li>
</ul>

</div>

<!-- *********************************************************************** -->
<div class="www_sectiontitle">
  <a name="improving">Improving the current system</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">

<p>Improvements to the current infrastructure are always very welcome and tend
to be fairly straight-forward to implement.  Here are some of the key areas that
can use improvement...</p>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="target-desc">Factor out target descriptions</a>
</div>

<div class="www_text">

<p>Currently, both Clang and LLVM have a separate target description infrastructure,
with some features duplicated, others "shared" (in the sense that Clang has to create
a full LLVM target description to query specific information).</p>

<p>This separation has grown in parallel, since in the beginning they were quite
different and served disparate purposes. But as the compiler evolved, more and
more features had to be shared between the two so that the compiler would behave
properly. An example is when targets have default features on speficic configurations
that don't have flags for. If the back-end has a different "default" behaviour
than the front-end and the latter has no way of enforcing behaviour, it simply
won't work.</p>

<p>Of course, an alternative would be to create flags for all little quirks, but
first, Clang is not the only front-end or tool that uses LLVM's middle/back ends,
and second, that's what "default behaviour" is there for, so we'd be missing the
point.</p>

<p>Several ideas have been floating around to fix the Clang driver WRT recognizing
architectures, features and so on (table-gen it, user-specific configuration files,
etc) but none of them touch the critical issue: sharing that information with the
back-end.</p>

<p>Recently, the idea to factor out the target description infrastructure from
both Clang and LLVM into its own library that both use, has been floating around.
This would make sure that all defaults, flags and behaviour are shared, but would
also reduce the complexity (and thus the cost of maintenance) a lot. That would
also allow all tools (lli, llc, lld, lldb, etc) to have the same behaviour
across the board.</p>

<p>The main challenges are:</p>

<ul>
  <li>To make sure the transition doesn't destroy the delicate balance on any
  target, as some defaults are implicit and, some times, unknown.</li>
  <li>To be able to migrate one target at a time, one tool at a time and still
  keep the old infrastructure intact.</li>
  <li>To make it easy for detecting target's features for both front-end and
  back-end features, and to merge both into a coherent set of properties.</li>
  <li>To provide a bridge to the new system for tools that haven't migrated,
  especially the off-the-tree ones, that will need some time (one release,
  at least) to migrate..</li>
</ul>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="code-cleanups">Implementing Code Cleanup bugs</a>
</div>

<div class="www_text">

<p>
The <a href="http://bugs.llvm.org/">LLVM bug tracker</a> occasionally
has <a
  href="http://bugs.llvm.org/buglist.cgi?short_desc_type=allwordssubstr&amp;short_desc=&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;keywords_type=allwords&amp;keywords=code-cleanup&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;emailassigned_to1=1&amp;emailtype1=substring&amp;email1=&amp;emailassigned_to2=1&amp;emailreporter2=1&amp;emailcc2=1&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;changedin=&amp;chfieldfrom=&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;order=Bug+Number&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=">"code-cleanup" bugs</a> filed in it.
Taking one of these and fixing it is a good way to get your feet wet in the
LLVM code and discover how some of its components work.  Some of these include
some major IR redesign work, which is high-impact because it can simplify a lot
of things in the optimizer.
</p>

<p>
Some specific ones that would be great to have:

<ul>
<li><a href="http://llvm.org/PR10367">Fix the design of GlobalAlias to not require dest type to match source type</a></li>
<li><a href="http://llvm.org/PR10368">Redesign ConstantExpr's</a></li>
<li><a href="http://llvm.org/PR11944">Static constructors should be purged from LLVM</a></li>
</ul>
</p>

<p>Additionally, there are performance improvements in LLVM that need to get
fixed. These are marked with the <tt>slow-compile</tt> keyword. Use
<a href="http://bugs.llvm.org/buglist.cgi?short_desc_type=allwordssubstr&amp;short_desc=&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;keywords_type=allwords&amp;keywords=slow-compile&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;emailassigned_to1=1&amp;emailtype1=substring&amp;email1=&amp;emailassigned_to2=1&amp;emailreporter2=1&amp;emailcc2=1&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;changedin=&amp;chfieldfrom=&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;namedcmd=Bugs+I+Fixed&amp;newqueryname=&amp;order=Reuse+same+sort+as+last+time&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=">this Bugzilla query</a>
to find them.</p>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="llvmtest">Add programs to the llvm-test testsuite</a>
</div>

<div class="www_text">

<p>
The <a href="docs/TestingGuide.html#wholeprograms">llvm-test</a> testsuite is
a large collection of programs we use for nightly testing of generated code
performance, compile times, correctness, etc.  Having a large testsuite gives
us a lot of coverage of programs and enables us to spot and improve any
problem areas in the compiler.</p>

<p>
One extremely useful task, which does not require in-depth knowledge of
compilers, would be to extend our testsuite to include <a href=
"http://nondot.org/sabre/LLVMNotes/#benchmarks">new programs and benchmarks</a>.
In particular, we are interested in cpu-intensive programs that have few
library dependencies, produce some output that can be used for correctness
testing, and that are redistributable in source form.  Many different programs
are suitable, for example, see <a
href="http://nondot.org/sabre/LLVMNotes/#benchmarks">this list</a> for some
potential candidates.
</p>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="programs">Compile programs with the LLVM Compiler</a>
</div>

<div class="www_text">

<p>We are always looking for new testcases and benchmarks for use with LLVM.  In
particular, it is useful to try compiling your favorite C source code with LLVM.
If it doesn't compile, try to figure out why or report it to the <a
href="http://lists.llvm.org/pipermail/llvm-bugs/">llvm-bugs</a> list.  If you
get the program to compile, it would be extremely useful to convert the build
system to be compatible with the LLVM Programs testsuite so that we can check it
into SVN and the automated tester can use it to track progress of the
compiler.</p>

<p>When testing a code, try running it with a variety of optimizations, and with
all the back-ends: CBE, llc, and lli.</p>

</div>


<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="benchmark">Benchmark the LLVM compiler</a>
</div>

<div class="www_text">

<p>Find benchmarks either using our <a
href="http://llvm.org/nightlytest/">test results</a> or on your own,
where LLVM code generators do not produce optimal code or simply where another
compiler produces better code.  Try to minimize the test case that demonstrates
the issue.  Then, either <a href="http://bugs.llvm.org/">submit a
bug</a> with your testcase and the code that LLVM produces vs. the code that it
<em>should</em> produce, or even better, see if you can improve the code
generator and submit a patch.  The basic idea is that it's generally quite easy
for us to fix performance problems if we know about them, but we generally don't
have the resources to go finding out why performance is bad.</p>

</div>


<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="statistics">Benchmark Statistics and Warning System</a>
</div>

<div class="www_text">

<p>The <a href='http://llvm.org/perf/db_default/v4/nts/recent_activity'>
LNT perf database</a> has some nice features like detect moving average,
standard deviations, variations, etc. But the report page give too much emphasis
on the individual variation (where noise can be higher than signal), eg.
<a href='http://llvm.org/perf/db_default/v4/nts/graph?plot.0=10.341.3&highlight_run=8943'>
this case</a>.</p>

<p>The first part of the project would be to create an analysis tool that would
track moving averages and report:
<ul>
 <li>If the current result is higher/lower than the previous moving average by
     more than (configurable) S standard deviations</li>
 <li>If the current moving average is more than S standard deviations of the
     Base run</li>
 <li>If the last A moving averages are in constant increase/decrease of more
     than P percent</li>
</ul>

<p>The second part would be to create a web page which would show all related
benchmarks (possibly configurable, like a dashboard) and show the basic statistics
with red/yellow/green colour codes to show status and links to more detailed
analysis of each benchmark.</p>

<p>A possible third part would be to be able to automatically cross reference
different builds, so that if you group them by architecture/compiler/number
of CPUs, this automated tool would understand that the changes are more common
to one particular group.</p>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="coverage">Improving Coverage Reports</a>
</div>

<div class="www_text">

<p>The <a href='http://llvm.org/reports/coverage/'>
LLVM Coverage Report</a> has a nice interface to show what source lines are
covered by the tests, but it doesn't mentions which tests, which revision and
what architecture is covered.</p>

<p>A project to renovate LCOV would involve:
<ul>
 <li>Making it run on a buildbot, so that we know what commits / architectures
     are covered</li>
 <li>Update the web page to show that information</li>
 <li>Develop a system that would report every buildbot build into the web page
     in a searchable database, like LNT</li>
</ul>

<p>Another idea is to enable the test suite to run all built backends, not just
   the host architecture, so that coverage report can be built in a fast machine
   and have one report per commit without needing to update the buildbots.</p>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="misc_imp">Miscellaneous Improvements</a>
</div>

<div class="www_text">

<ol>

<li>Completely rewrite bugpoint.  In addition to being a mess, bugpoint suffers
from a number of problems where it will "lose" a bug when reducing.  It should
be rewritten from scratch to solve these and other problems.</li>
<li><a href="http://bugs.llvm.org/show_bug.cgi?id=2116">Add support for
transactions to the PassManager</a> for improved bugpoint.</li>
<li><a href="http://bugs.llvm.org/show_bug.cgi?id=539">Improve bugpoint to
support running tests in parallel on MP machines</a>.</li>
<li>Add MC assembler/disassembler and JIT support to the SPARC port.</li>
<li>Move more optimizations out of the <tt>-instcombine</tt> pass and into
InstructionSimplify.  The optimizations that should be moved are those that
do not create new instructions, for example turning <tt>sub i32 %x, 0</tt>
into <tt>%x</tt>.  Many passes use InstructionSimplify to clean up code as
they go, so making it smarter can result in improvements all over the place.</li>
</ol>

</div>

<!-- *********************************************************************** -->
<div class="www_sectiontitle">
  <a name="new">Adding new capabilities to LLVM</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">

<p>Sometimes creating new things is more fun than improving existing things.
These projects tend to be more involved and perhaps require more work, but can
also be very rewarding.</p>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="llvm_ir">Extend the LLVM intermediate representation</a>
</div>

<div class="www_text">

<p>Many proposed <a href="http://nondot.org/sabre/LLVMNotes/">extensions and
improvements to LLVM core</a> are awaiting design and implementation.</p>

<ol>
<li><a href="http://nondot.org/sabre/LLVMNotes/DebugInfoImprovements.txt">Improvements
for Debug Information Generation</a></li>
<li><a href="http://llvm.org/PR1269">EH support for non-call exceptions</a></li>
<li>Many ideas for feature requests are stored in LLVM bugzilla.  Just <a
  href="http://bugs.llvm.org/buglist.cgi?short_desc_type=allwordssubstr&amp;short_desc=&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;keywords_type=allwords&amp;keywords=new-feature&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;emailassigned_to1=1&amp;emailtype1=substring&amp;email1=&amp;emailassigned_to2=1&amp;emailreporter2=1&amp;emailcc2=1&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;changedin=&amp;chfieldfrom=&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;namedcmd=All+PRs&amp;newqueryname=&amp;order=Bug+Number&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=">search for bugs with a "new-feature" keyword</a>.</li>
</ol>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="pointeranalysis">Pointer and Alias Analysis</a>
</div>

<div class="www_text">

<p>We have a <a href="docs/AliasAnalysis.html">strong base for development</a> of
both pointer analysis based optimizations as well as pointer analyses
themselves.  It seems natural to want to take advantage of this:</p>

<ol>
<li>The globals mod/ref pass basically does really simple and cheap
bottom-up context sensitive alias analysis.  It being simple and cheap
are really important, but there are simple things that we could do to
better capture the effects of functions that access pointer
arguments.  This can be really important for C++ methods, which spend
lots of time accessing pointers off 'this'.</li>

<li>The alias analysis API supports the getModRefBehavior method, which
allows the implementation to give details analysis of the functions.
For example, we could implement <a href="http://llvm.org/PR1604">full knowledge
of printf/scanf</a> side effects, which would be useful.  This feature is in
place but not being used for anything right now.</li>
<li>We need some way to reason about errno.  Consider a loop like this:

<pre>
    for ()
      x += sqrt(loopinvariant);
</pre>

<p>We'd like to transform this into:</p>

<pre>
    t = sqrt(loopinvariant);
    for ()
      x += t;
</pre>

<p>This transformation is safe, because the value of errno isn't
otherwise changed in the loop and the exit value of errno from the
loop is the same.  We currently can't do this, because sqrt clobbers
errno, so it isn't "readonly" or "readnone" and we don't have a good
way to model this.</p>

<p>The hard part of this project is figuring out how to describe errno
in the optimizer: each libc #defines errno to something different it
seems.  Maybe the solution is to have a __builtin_errno_addr() or
something and change sys headers to use it.</p>

<li>There are lots of ways to optimize out and <a
href="http://llvm.org/PR452">improve handling of
memcpy/memset</a>.</li>

</ol>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="profileguided">Profile-Guided Optimization</a>
</div>

<div class="www_text">

<p>We now have a unified infrastructure for writing profile-guided
transformations, which will work either at offline-compile-time or in the JIT,
but we don't have many transformations.  We would welcome new profile-guided
transformations as well as improvements to the current profiling system.
</p>

<p>Ideas for profile-guided transformations:</p>

<ol>
<li>Superblock formation (with many optimizations)</li>
<li>Loop unrolling/peeling</li>
<li>Profile directed inlining</li>
<li>Code layout</li>
<li>...</li>
</ol>

<p>Improvements to the existing support:</p>

<ol>
<li>The current block and edge profiling code that gets inserted is very simple
and inefficient.  Through the use of control-dependence information, many fewer
counters could be inserted into the code.  Also, if the execution count of a
loop is known to be a compile-time or runtime constant, all of the counters in
the loop could be avoided.</li>

<li>You could implement one of the "static profiling" algorithms which analyze a
piece of code an make educated guesses about the relative execution frequencies
of various parts of the code.</li>

<li>You could add path profiling support, or adapt the existing LLVM path
profiling code to work with the generic profiling interfaces.</li>
</ol>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="compaction">Code Compaction</a>
</div>

<div class="www_text">
<p>LLVM aggressively optimizes for performance, but does not yet optimize for code size.
With a new ARM backend, there is increasing interest in using LLVM for embedded systems
where code size is more of an issue.
</p>

<p>Someone interested in working on implementing code compaction in LLVM might want to read
<a href="http://citeseer.ist.psu.edu/425696.html">this</a> article, describing using
link-time optimizations for code size optimization.
</p>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="xforms">New Transformations and Analyses</a>
</div>

<div class="www_text">

<ol>
  <li>Implement a Loop Dependence Analysis Infrastructure<br>
    - Design some way to represent and query dep analysis</li>
  <li>Value range propagation pass</li>
  <li>More fun with loops:
    <a href="http://www.cs.ualberta.ca/~amaral/cascon/CDP04/tal.html">
      Predictive Commoning
    </a>
  </li>
  <li>Type inference (aka. devirtualization)</li>
  <li><a href="http://nondot.org/sabre/LLVMNotes/BuiltinUnreachable.txt">Value
      assertions</a> (also <a href="http://llvm.org/PR810">PR810</a>).</li>
</ol>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="codegen">Code Generator Improvements</a>
</div>

<div class="www_text">

<ol>
<li>Generalize target-specific backend passes that could be target-independent,
    by adding necessary target hooks and making sure all IR/MI features (such as
    register masks and predicated instructions) are properly handled. Enable these
    for other targets where doing so is demonstrably beneficial.
    For example:
      <ol><li>lib/Target/Hexagon/RDF*</li>
          <li>lib/Target/AArch64/AArch64AddressTypePromotion.cpp</li>
     </ol>
    </li>
<li>Merge the delay slot filling logic that is duplicated into (at least)
    the Sparc and Mips backends into a single target independent pass.
     Likewise, the branch shortening logic in several targets should be merged
     together into one pass.</li>
<li>Implement 'stack slot coloring' to allocate two frame indexes to the same
    stack offset if their live ranges don't overlap.  This can reuse a bunch of
    analysis machinery from LiveIntervals.  Making the stack smaller is good
    for cache use and very important on targets where loads have limited
    displacement like ppc, thumb, mips, sparc, etc.  This should be done as
    a pass before prolog epilog insertion.  This is now done for register
    allocator temporaries, but not for allocas.</li>
<li>Implement 'shrink wrapping', which is the intelligent placement of callee
    saved register save/restores.  Right now PrologEpilogInsertion always saves
    every (modified) callee save reg in the prolog and restores it in the
    epilog.  However, some paths through a function (e.g. an early exit) may
    not use all regs.  Sinking the save down the CFG avoids useless work on
    these paths. Work has started on this, please inquire on llvm-dev.</li>
<li>Implement interprocedural register allocation. The CallGraphSCCPass can be
    used to implement a bottom-up analysis that will determine the *actual*
    registers clobbered by a function. Use the pass to fine tune register usage
    in callers based on *actual* registers used by the callee.</li>
<li>Add support for 16-bit x86 assembly and real mode to the assembler and
    disassembler, for use by BIOS code. This includes both 16-bit instruction
    encodings as well as privileged instructions (lgdt, lldt, ltr, lmsw, clts,
    invd, invlpg, wbinvd, hlt, rdmsr, wrmsr, rdpmc, rdtsc) and the control and
    debug registers.
</ol>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="misc_new">Miscellaneous Additions</a>
</div>

<div class="www_text">

<ol>
<li>Port the <a href="http://www-sop.inria.fr/mimosa/fp/Bigloo/">Bigloo</A>
Scheme compiler, from Manuel Serrano at INRIA Sophia-Antipolis, to
output LLVM bytecode. It seems that it can already output .NET
bytecode, JVM bytecode, and C, so LLVM would ostensibly be another good
candidate.</li>
<li>Write a new frontend for some other language (Java? OCaml? Forth?)</li>
<li>Random test vector generator: Use a C grammar to generate random C code,
e.g., <a href="http://code.google.com/p/quest-tester/">quest</a>;
run it through llvm-gcc, then run a random set of passes on it using opt.
Try to crash <tt><a href="/docs/CommandGuide/html/opt.html">opt</a></tt>. When
<tt>opt</tt> crashes, use <tt><a
href="/docs/CommandGuide/html/bugpoint.html">bugpoint</a></tt> to reduce the
test case and post it to a website or mailing list.  Repeat ad infinitum.</li>
<li>Add sandbox features to the Interpreter: catch invalid memory accesses,
  potentially unsafe operations (access via arbitrary memory pointer) etc.
</li>
<li>Port <a href="http://valgrind.org">Valgrind</a> to use LLVM code generation
  and optimization passes instead of its own.</li>
<li>Write LLVM IR level debugger (extend Interpreter?)</li>
<li>Write an LLVM Superoptimizer.  It would be interesting to take ideas from
    this superoptimizer for x86:
<a href="http://theory.stanford.edu/~aiken/publications/papers/asplos06.pdf">paper #1</a> and <a href="http://theory.stanford.edu/~sbansal/superoptimizer.html">paper #2</a> and adapt them to run on LLVM code.<p>

It would seem that operating on LLVM code would save a lot of time
because its semantics are much simpler than x86.  The cost of operating
on LLVM is that target-specific tricks would be missed.<p>

The outcome would be a new LLVM pass that subsumes at least the
instruction combiner, and probably a few other passes as well.  Benefits
would include not missing cases missed by the current combiner and also
more easily adapting to changes in the LLVM IR.<p>

All previous superoptimizers have worked on linear sequences of code.
It would seem much better to operate on small subgraphs of the program
dependency graph.</li>
</ol>

</div>

<!-- *********************************************************************** -->
<div class="www_sectiontitle">
  <a name="using">Projects using LLVM</a>
</div>
<!-- *********************************************************************** -->

<div class="www_text">

  <p>
  In addition to projects that enhance the existing LLVM infrastructure, there
  are projects that improve software that uses, but is not included with, the
  LLVM compiler infrastructure.  These projects include open-source software
  projects and research projects that use LLVM.  Like projects that enhance the
  core LLVM infrastructure, these projects are often challenging and rewarding.
  </p>

</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="encodeanalysis">Encode Analysis Results in MachineInstr IR</a>
</div>

<div class="www_text">
  <p>
  At least one project (and probably more) needs to use analysis information
  (such as call graph analysis) from within a MachineFunctionPass.  However,
  most analysis passes operate at the LLVM IR level.  In some cases, a value
  (e.g., a function pointer) cannot be mapped from the MachineInstr level back
  to the LLVM IR level reliably, making the use of existing LLVM analysis
  passes from within a MachineFunctionPass impossible (or at least brittle).
  </p>

  <p>
  This project is to encode analysis information from the LLVM IR level into
  the MachineInstr IR when it is generated so that it is available to a
  MachineFunctionPass.  The exemplar is call graph analysis (useful for
  control-flow integrity instrumentation, analysis of code reuse defenses, and
  gadget compilers); however, other LLVM analyses may be useful.
  </p>
</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="codelayoutjit">Code Layout in the LLVM JIT</a>
</div>

<div class="www_text">
  <p>
  Implement an on-demand function relocator in the LLVM JIT. This can help
  improve code locality using runtime profiling information. The idea is to use
  a relocation table for every function.  The relocation entries need to be
  updated upon every function relocation (take a look at
  <a href="https://people.cs.umass.edu/~emery/pubs/stabilizer-asplos13.pdf">
  this article</a>).
  A (per-function) basic block reordering would be a useful extension.
  </p>
</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="fieldlayout">Improved Structure Splitting and Field Reordering</a>
</div>

<div class="www_text">
  <p>
  The goal of this project is to implement better data layout optimizations
  using the model of reference affinity.  This
  <a href="http://www.cs.rochester.edu/~cding/Documents/Publications/pldi04.pdf">
  paper</a>
  provides some background information.
  </p>
</div>

<!-- ======================================================================= -->
<div class="www_subsubsection">
  <a name="slimmer">Finish the Slimmer Project</a>
</div>

<div class="www_text">
  <p>
  Slimmer is a prototype tool, built using LLVM, that uses dynamic analysis to
  find potential performance bugs in programs.  Development on Slimmer started
  during Google Summer of Code in 2015 and resulted in an initial prototype,
  but evaluation of the prototype and improvements to make it portable and
  robust are still needed.  This project would have a student pick up and
  finish the Slimmer work.  The source code of Slimmer and
  its current documentation can be found at its
  <a href="https://github.com/james0zan/Slimmer">Github</a> web page.
  </p>
</div>

<!-- *********************************************************************** -->

<hr>
<address>
  <a href="http://jigsaw.w3.org/css-validator/check/referer"><img
  src="http://jigsaw.w3.org/css-validator/images/vcss" alt="Valid CSS!"></a>
  <a href="http://validator.w3.org/check/referer"><img
  src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01!"></a>

  <a href="http://llvm.org">LLVM Compiler Infrastructure</a><br>
</address>

<!--#include virtual="footer.incl" -->
